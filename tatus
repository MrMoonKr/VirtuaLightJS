[1mdiff --git a/main/startup.js b/main/startup.js[m
[1mindex 508fe44..8c79b0a 100644[m
[1m--- a/main/startup.js[m
[1m+++ b/main/startup.js[m
[36m@@ -229,7 +229,7 @@[m [mfunction drawSceneIfReady(){[m
 }[m
 [m
 function loadObjects(){[m
[31m-    var debug = 0;[m
[32m+[m[32m    var debug = 1;[m
     if(debug){[m
         var mats = [m
         {[m
[36m@@ -352,6 +352,8 @@[m [mfunction loadObjects(){[m
 [m
     // Create a plan underneath both objects[m
     material = new MeshMaterial(mats.floor);[m
[32m+[m[32m    // Override metallic property as it is fully metal by default[m
[32m+[m[32m    material.fresnel = Texture.generateTextureFromData(new Uint8Array(3).fill(0.0), 1, 1, false, gl.REPEAT, gl.NEAREST);[m
     mesh = new Mesh(material);[m
     mesh.makePlan(3.0, 50);[m
     entities.push(new Entity(mesh, "Floor", Matrix.I(4)));[m
[1mdiff --git a/shaders/fragment_shader.fs b/shaders/fragment_shader.fs[m
[1mindex dce8d57..93f111b 100644[m
[1m--- a/shaders/fragment_shader.fs[m
[1m+++ b/shaders/fragment_shader.fs[m
[36m@@ -98,6 +98,7 @@[m [mvoid main(void) {[m
     // Fresnel f0 term[m
     vec3 f0 = vec3(0.04); [m
     f0 = mix(f0, albedo, fresnel);[m
[32m+[m[32m    vec3 Ld = vec3(0.0);[m[41m[m
 [m
     for (int i=0 ; i<nbLights; i++){[m
 [m
[36m@@ -117,6 +118,7 @@[m [mvoid main(void) {[m
         vec3 radiance = vec3(u_perPass.lights[i].color) * getIntensityFromPosition(u_perPass.lights[i],pos);[m
 [m
         LO += (kD * albedo / M_PI + specular) * radiance * directionnalAttenuation;[m
[32m+[m[32m        Ld += (kD * albedo / M_PI) * radiance * directionnalAttenuation;[m[41m[m
 [m
     }[m
 [m
[36m@@ -151,8 +153,6 @@[m [mvoid main(void) {[m
     resultingColor = mix( resultingColor, vec3(1.0, 1.0, 1.0), PrintValue( (gl_FragCoord.xy - vec2(0.0, 5.0)) / vFontSize, [m
         u_perPass.lights[nbLights-1].intensity / 200.0, 4.0, 10.0));*/[m
 [m
[31m-    // Tone mapping by reinhart operator[m
[31m-    //resultingColor = resultingColor / (resultingColor + vec3(1.0));[m
     // Exposure tone mapping[m
     //float exposure = 1.0; // => should be a uniform[m
     resultingColor = vec3(1.0) - exp(-resultingColor * exposure);[m
